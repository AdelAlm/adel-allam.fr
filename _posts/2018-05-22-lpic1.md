---
layout: post
title: lpic-1
categories: linux
---
<!--more-->

---
# I - Get help
---
### --help/-h
```bash
# help option
$ ls --help

# show internal (builtin) commands
$ help

# internal command help
$ help pdw
```

### man

|section |content                                               |   
|:-------|:-----------------------------------------------------|
|1       |shell commands or instruction                         |
|2       |system calls (API du noyau,...)                       |
|3       |appels des bibliothèques (fonctions C,...)            |
|4       |special files (contenu de /dev comme sd, hd, pts,...) |
|5       |files format (/etc/passwd, /etc/hosts,...)            |
|6       |games, screen saver, gadgets,...                      |
|7       |non standard commands                                 |
|8       |commands for system administration                    |
|9       |sous-programme du noyaun (souvent vide)               |

```bash
# manual page
$ man passwd

# give number page
$ man -5 passwd

# search command
$ man -k passwd
```

### info
Info pages: format + links + page navigation.

```bash
# info page
$ info sed

# show command options
$ info --show-options date

# search command
$ info --apropos date
```

---
# II - Shared libraries
---
* linking with `ld`, used by `gcc -l <lib>`
* Shared Object `.so`
* location:
  * `/lib[64]`: system libraries, essential for boot
  * `/usr/lib`: for users, non essential for boot
  * `/usr/local/lib`: local libraries
  * `/usr/X11/lib`: for programs
  * systemd moved `/lib[64]` in `/usr/lib[64]`
* `/lib/x86_64-linux-gnu/libc.so`: most important lib
* a lot of symlink to manage versions

`ld.so` or `ld-linux.so`: search libs and manage cache.

```bash
# all programs are linked to ld.so
# program's libs
$ ldd /bin/vim

# global conf
$ vim /etc/ld.so.conf

# personal conf
$ vim /etc/ld.so.conf.d/

# order for the search
$ LD_LIBRARY_PATH=
$ /etc/ld.so.cache
$ /lib[64]

# regenerate cache
$ sudo ldconfig -V
# -V: verbose
# -N: don't regenerate cache
# -X: not link updates
# -p: list cache content
```
---
---

---
# I - Shell
---
* `bash`: command interpretor
* `kernel`: noyau
* `shell`: coquille, ce qui entoure le noyau
  > Ex: sh, csh, ksh, zsh, bash, tcsh, ash, dash

```bash
# all shells available
$ vim /etc/shells

$ # user prompt
# # root prompt

$ echo -e "Salut \t ça va ?\n"
# \n: saut ligne
# \t: tabulation
# \c: supprimer sout de ligne final
# \b: retour d'un caractère en arrière

# chainer commande
$ date; pwd; cal; echo
```

|cheat sheet |action                  |   
|:-----------|:-----------------------|
|`ctrl + a`  |aller debut ligne       |
|`ctrl + e`  |aller fin ligne         |
|`ctrl + l`  |effacer                 |
|`ctrl + u`  |efffacer jusqu'au début |
|`ctrl + k`  |effacer jusqu'à la fin  |
|`ctrl + w`  |effacer mot à gauche    |

### command type
```bash
# external: in the hard drive, load in memory for execution
# internal: in shell, execution inside shell (cd, pwd)

$ type date
# date is /usr/bin/date

$ type pwd
# shell builtin
```
### interruption

|cheat sheet |action                      |
|:-----------|:---------------------------|
|`ctrl + c`  |on demande qu'il se termine |
|`ctrl + z`  |mettre en pause             |
|`ctrl + d`  |fin de saisie               |

### history
```bash
$ cat .bash_history # user history
$ history # recent history
$ fc -l # recent history
$ fc -s 118 # call command
$ fc -s fc=ls 21 # with replacement
```

### files

```bash
# FS: File System
# 1-regular files
# 2-directory
# 3-special files (/dev)

$ cd / # root directory != /root
$ cd /home/mourad # home directory
$ cd ~
$ touch # change date

$ mkdir -p # create  arborescence

$ cp
$ mv
$ rm
# -r : recursive
# -i : confirmation
# -p : keep date and permissions

$ cat
$ ln -s file link
# red symbolique links = ne pointe vers rien

# ls size = taille fichier ordinaire seulement et non sous repertoire (du)

# remove le file -i
$ rm -- -i

$ file a.out # file type
```

### wildcards

|wildcards |action                        |   
|:---------|:-----------------------------|
|`*`       |                              |
|`?`       |                              |
|`[abc]`   |                              |
|`[a-z]`   |                              |
|`[!...]`  |inverse                       |
|`[^...]`  |inverse                       |
|`\`       |escape character              |
|`'...'`   |escape all                    |
|`"..."`   |escape all but keep variables |

### find

|option      |example                 |   
|:-----------|:-----------------------|
|`-name`     |`fich*`                 |
|`-type`     |`b,c,d,f,l,p,s`         |
|`-user`     |`mourad or UID`         |
|`-group`    |`root or GID`           |
|`-size`     |`+-100b,c,w,k,M,G`      |
|`-empty`    |`-size 0`               |
|`-atime`    |`access time`           |
|`-mtime`    |`modification time`     |
|`-ctime`    |`change time`           |
|`-perm`     |`[+-]777`               |
|`-links`    |`[+-]3`                 |
|`-inume`    |`inode`                 |
|`-[i]regex` |`'.*slyunix/t-shirt.*'` |
|`-print`    |`implicite`             |
|`-ls`       |``                      |
|`-exec`     |`rm -f {} \;`           |
|`-ok`       |`rm -f {} \;`           |
|`-a`        |`-and`                  |
|`-o`        |`-or`                   |
|`!`         |`not`                   |

  > Ex: `$ find . ! \( -type f -o -type d \) -ls`

```bash
$ whereis # cherche binaire et source, -b, -m, s
$ which [-a] # premiére occurence dans $PATH
$ locate # chercher fichier via BDD /var/lib/located.d via updatedb dans /etc/sysconfig/locate
```

### redirection
```bash
# standard output
$ ls -al /home/ > home_content.txt
$ ls -al /home/ >> home_content.txt
# redirections are interpreted from right to the left

$ wc < text.txt # standard input

$ wc \<\< fin # writing to "fin"
$ tr "[a-z]" "[A-Z]" \<< fin
$ tr "[a-z]" "[A-Z]" <<< $(cat file)

# standard output
# input: stdin, descriptor 0 or &0
# output: stdout, descriptor 1 or &1
# error: stderr, descriptor 2 or &2
# order: <,>,>>

$ exec 3>dump.log # create output (3 to 9)
ls -l >&3 # used
exec 3>&- # closed
```

### filters
programme which read and write and traite data of standard output: `wc`, `more`, `grep`
pipeline, tubes, pipe
redirigiger canal de sortie d'une commande vers canal d'entrée d'une autre
redirect command output to input of other command

```bash
# normal
$ ls -l > res.txt
$ wc < res.txt

$ ls -l | wc # better

$ direname /tmp/a/liste # -> /tmp/mourad
$ basename /tmp/a/liste # -> liste

# grep, egrep, fgrep: select lines from file
# -v inverse
# -c return line number
# -n give the line number also
# -i case sensitive
# -l give source, in case of multipl files

# regular expressions
$ egrep
$ grep -E

# fast grep
$ fgrep
$ grep -F

# stream editor
$ sed -e 's/__NOM__/Toto/g' file.txt
$ sed -e "s/\(toto\)/**\1**/g" file.txt
$ sed -e '/^ *$/d' file.txt: remove empty lines

# columns
$ cut -cNUM
$ cut -c2
$ cut -c2-4
$ cut -c1,2,3-10

# fields
$ cut -dC -fCHAMP: sélectionner champ séparé par tab
$ cut -f1 fichier
$ cut -f1,3 fichier
$ cut -d: -f1,3 /etc/passwd

# count lines
$ wc 
# -l : lines 
# -c : bytes
# -w : words
# -m : characters

# split file
$ split [-ln] [-b Nbkm] [fic[prefix]]
$ split -b 150m debian.iso fic
# will create ficaa, ficab,...
# -b: all files have same size
# -l: ... have same lines number

$ cat fic* > debian.iso # reconstrution

$ tr [option] original dist # replace character
$ cat liste.txt | tr "oi" "ea"

# replace spaces by :
$ tr -s " " ":"

$ expand # tabulation to spaces
$ unexpand # spaces to tab

# manage output
# read output delimited by space or line break
# and execute command on them
$ cat input | xargs
$ cat input | xargs -n 2
# 2 columns

# other
$ sort
$ uniq
$ join
$ paste

$ cat
$ tac
$ hexdump
$ od
$ banner
$ cat -n ou nl
$ head
$ tail -f

$ column -s: -t /etc/passwd

# duplication du canal
$ tee [-a]
$ cat /etc/passwd | cut -d: -f1 | tee users.txt | wc -l
# -a: append, n'écrase pas contenu fichier

$ diff
$ comp

$ sleep 10

# controler flux
$ pv test > test2
# durée compression
pv /blabla/fic | gzip > test.gz
```

---
# II - Process
---

* `PID`
* `PPID`
* `UID`
* `GID`
* `priority`
* `working directory`
* opened files (descripteurs)
processus fils du shell pour lancer commandes
ls -R / > ls.txt 2>/dev/null &
le process en fond ne doit pas attendre de saisie
pas d'affichage
ne pas quitter shell avec traitement

```bash
$ jobs
numJob PID
ctrl + z: mettre en pause

$ fg # to foreground
$ bg # to background

### list process
$ ps # process launch by user from current shell

$ ps -ef # all process
# -f: more info
# -e: all process
# -u mourad
# -g wheel
# -t tty0: terminal
# -p 123445
# l: more more info
```

### signals
```bash
# show all available signals
$ kill -l
# 1(SIGHUP): send by parent process before die
# 2(SIGINT): interruption (ctrl + c)
# 3(SIGQUIT): interruption + core dump
# 9(SIGKILL): force fin brutale
# 15(SIGTERM): by default, fin gentille

$ kill 1234 # kill process by PID
$ kill -n 9 1234 # with signal
$ pkill firefox # kill process with its name

$ pgrep sleep # get PID with process name

$ nohup ls -lR / & # ne plus tenir compte du SIGHUP lorsque le pére meurt
```

### priority
```bash
# launch command with priority
$ nice -10 ls -lR >list 2>/dev/null &

# change priority of process
$ renice -n 10 [-p] [-g] [-u] 1234

$ time ls -lR /home
# real: durée total exec commande
# user: CPU time
# system: durée du temps CPU necessaire pour éxecuter commande

$ exec ksh # replace current process by another
```

### groupement
```bash
$ uname -a ; pwd ; ls -l > res.txt & # multipls shells
$ (uname -a ; pwd ; ls -l) > res.txt & # one shell

# return code of last command
# echo $?
# 0 : success
# else : error

$ cmd && cmd # and
$ cmd || cmd # or

$ (exit) # launch in child
$ {exit ;} # launch in current shell
```
### les variables
```bash
# user (minuscules)
# system (majuscules)
# speciale

# variable
$ nom=Mourad
$ echo $nom

$ env # show user and system variables

$ "..." # read variables
$ '...' # don't read variables

$ unset nom # delete var
$ readonly nom # protect var (read only and can't delete)
$ export nom # share var with shell children, but modification is limited

$ cp ${fic}1 ${fic}2 # accolades

### replacement
$ {x:-texte} # if x empty, else texte
$ {x:=texte} # if x empty, x=texte
$ {x:-texte} # if x not empty, x=texte 
$ {x:?texte} # if x empty, script stopped and display texte
```

### system variables

|variable    |content                                        | 
|:-----------|:----------------------------------------------|
|`$HOME`     |                                               |
|`$PATH`     |                                               |
|`$PS1`      |                                               |
|`$PS2`      |                                               |
|`$PS3`      |                                               |
|`$IFS`      |caractère standard de séparation des commandes |
|`$MAIL`     |chemin des mails                               |
|`$SHELL`    |                                               |
|`$LANG`     |                                               |
|`$USER`     |                                               |
|`$LOGNAME`  |                                               |
|`$HISTFILE` |nom fichier history                            |
|`$HISTSIZE` |taille histiry                                 |
|`$OLDPWD`   |                                               |
|`$PWD`      |                                               |
|`$RANDOM`   |(0 à 32767)                                    |

### speciale variables
```bash
# readonly, contexctual content
$ echo $? # return code of last command
$ echo $$ # PID of current shell
$ echo $! # PID of last shell launch with &
$ echo $- # shell options
```

### strings
```bash
$ a=Jules
$ echo "Longueur de $a: ${#a}"

# array
$ nom[0]="test"
$ nom[1]="a"

$ echo ${nom[1]}
# or
$ nom=(text,a)
$ echo ${nom[*]}
$ echo ${#nom[*]}
# si index est variable, pas de $
index=0

$ echo ${nom[index]}

# variables typées
# entier
$ typeset -i ma_var
$ let res = ma_var + 5 res2=a+b
# ou ((...))
```

### le shell
connexion
* shell connexion
* lance le shell du user dans `/etc/passwd`
* `/etc/profile` (inclu `/etc/profile.d/*`)
* `~/.bash_profile`
* `~/.bash_login`
* `~/.profile`

déconnexion
* `~/.bash_logout`

shell mode non intéractif (pour les process)
pas de script au démarrage
BASH_ENV: permet d'en éxecuter un

```bash
$ set
pour donner option à bash: man bash
# -a
# -u
# -x
# -o vim
# -C
```

---
# III - Shell program
---
```bash
#!/bin/bash
# le sha-bang
# chmod 555 scriptname (gives everyone read/execute permission)
# chmod u+rx scriptname (gives only the script owner read/execute permission)
# A script needs read, as well as execute permission for it to run, since the shell needs to be able to read it.
```

```bash
# file in .sh .ksh .csh

# executable mode
$ chmod +x my_script.sh

$ ./my_script.sh

$ PATH=$PATH:.
$ my_script.sh

$ cat my_script.sh
#!/bin/bash (+ options)

# ; = lign jump
```

---
# IV - Arguments
---
```bash
# position parameters = speciales variables

# script name
$ echo $0

# parameters
$ echo $1...9

# parametres numbers
$ echo $#

# "$1 $2 $3 ..."
$ echo $*

# "$1" "$2" "$3" ...
$ echo $@

# $1=var1 $2=var2 $3=var3
$ set var1 var2 var3

$ $1=$2 $2=$3
$ shift
$ shift 4

# return 0 and quit
$ exit
$ exit 1

# return value
$ echo $?
```

---
# V - Process environnement
---
```bash
# only exported values are available in script environnement

# see environnement
$ env

# share var without export for every script
$ env var1=val1 var2=val2 m_script.sh

# on bash
$ var1=val1 var2=val2 m_script.sh

# only standard output is on variable
# the error output is in screen
```

---
# VI - Command substitution
---
```bash
$ my_unix=`uname`
$ machine=`uname -a | cut -d" " -f5`

# bash
$ $() replace ```
```

---
# VII - Conditions
---
### strings
```bash
# 0 if $var is empty
$ test -z "$var"

# 0 if $var is not empty
$ test -n "$var"

# 0 if equals
$ test "var" = $var

# 0 if different
$ test "var" != $var

# "$a" is better than $a
```

### numeric
```bash
# test val1 option val2
# options
# -eq : ==
# -ne : !=
# -lt : < (less than)
# -gt : > (greater than)
# -le : <= (less or equal)
# -ge : >= (greater or equal)
```

### files
```bash
# test option file
# options
# -d
# -c (caracter mode)
# -b
# -p
# -r
# -w
# -x
# -s (not empty)
# -e (exist)
# -L (simlink)
# -u (exist + SUID)
# -g (exist + GUID)
```

### combinés
```bash
# -a : and
# -o : or
# ! : non
# \(...\)
$ test -d "rep1" -a -w "rep1" && ...
```

---
# VII - Better syntax
---
```bash
$ # test -> [ ... ]
# [[ ... ]] : more rapid, no process, force command interne
# can use && (-a) and || (-o)
```

---
# IX - Shell program
---
### if
```bash
if [ $# -ne 2 ]
then
  echo "Give 2 args please"
  echo "Ex: $0 10 20"
  exit 1
fi

x=$1
y=$2

if [ $x -eq $y ]
then
  echo "values avec equals"
elif [ $x -lt $y ]
then
  echo "$x is less than $y"
else
  echo "$x is bigger or equal to $y"
fi

# command
if [[ $? -eq 0 ]]

# C syntax
if (( $(command) ))
```

### case
```bash
case $x in
  1)  echo "la premiere valeur est 10" ;;
  2)  echo "la premiére valeur est 20" ;;
  *) echo "je ne reconnais pas la valeur" ;;
esac

# *
# ?
# [...]
# [!...]
# | : logic or
```

```bash
echo -n "Nom: " ; read nom
echo -n "Prénom: " ; read prenom
echo "Bonjour $prenom $nom !"
```

### for
```bash
for elt in $@
do
  echo "je suis dans la boucle $elt"
done

for elt in $(seq 3)
do
  echo "je suis dans la boucle $elt"
done

for (( i=1; i<10; i++ ))
do
  echo "je suis dans la boucle $i"
done

for int in $(seq 100)
do
  echo "int: $int"
  if [ $int -eq 10 ]
  then
    echo "int vaut 10 !!"
    break # suite apres le premier donne rencontré
    # continue # passe boucle suivante, peut prendre arg
  fi
done
```

### while
```bash
debut=0
typeset -i debut
fin=4
while [ $debut -ne $fin ]
do
  echo "les valeurs ne sont pas egales"
  eval debut=$debut+1
done

echo "Saisisez une commande (> fin pour quitter)"
while true # ou while :
do
    echo -n "> " ; read rep
    if [ "$rep" = "fin" ]
    then
        break
    fi
done
```


### until
```bash
until [ $debut -ne $fin ]
do
  echo "les valeurs ne sont pas"
  eval debut=$debut+1
done
```

### select
```bash
PS3="Votre réponse > "
select elt in Bonjour Salut Yolo
do
  case $elt in
    "Bonjour") echo "Vous avez choisie Bonjour" ; break;;
    "Salut") echo "Vous avez choisie Salut" ; break;;
    "Yolo") echo "Vous avez choisie Yolo" ; break;;
  esac
done
```


### functions
```bash
my_fonction() {
  echo "Je suis dans la fonction de $prenom $nom"
  return 0
}

prenom=mourad
nom=allam
ma_fonction $prenom $nom

eval \$$b
```

```bash
. mon_fichier.sh

my_function

a=10
# expr prend que des nombres
expr 2 + 3
expr $a + 3
expr $a != 3
a=$((a + 1))

echo "3/6" | bc -l

b=20
eval echo \$$b

signal_recu () {
  echo 'je viens de recevoir un signal'
}

trap 'signal_recu' SIGINT

sleep 10

old_IFS="$IFS"
IFS=:
echo "Please input some data separated by colons ..."
read x y z
IFS=$old_IFS
echo "x is $x y is $y z is $z"
```
---
---

---
# I - Répresentation des disques
---
* disques dans /dev

### controleur IDE (ancien)
en hdX
hda, hdb, hdc,...

port extension machine = slot PCI
hdX n'existe plus sur dernière version du noyau

### controleur SCSI, SATA, USB,...
sdX
sda, sdb, sdc,...
nom suivant ordre detection
CD, DVD, Blueray: srX, sr0, sr1, sr2
aussi en scd0 mais pointe vers sr0

```bash
# affiche périphérique SCSI
$ lsscsi
```

### controleur spécifique
cXdYpZ
X: slot
Y: disque
Z: partition

### virtualisation
vitual disk
Ex:vda, vdb ou xvda, xvdb

# Manipulation de bas niveau
disqueq géré par bibliothéque libata, on peut faire des modifs (p271)
```bash
# SATA, ATA (IDE), SAS
$ hdparam
$ hdparam -I /dev/sda # info depuis noyau
$ hdparam -I /dev/sda # info depuis disque

# SCSI
$ sdparam
```

# Système de fichier
on organise le support d'une certaine manière afin de pourvoir y stocker des données
associer nom fichier à son contenu + meta-data
255 caractères max
extension inutile != Windows
type fichier determiné par le premier octet (type MIME)
```bash
# utilise type MIME
$ type mon_fichier
```

# Journalisation
* garantir intégrité données
* le FS maintient un journal dans lequel il trace tous les changements intervenus avant de les effectuer réellement et de les pointer une fois terminés
* en cas de coupure, relit journal et rejoue opération si nécessaire

|file system       |caractéristiques     | 
|:--------------|:--------|
|`ext2` |FS historique, non journalisé, rapide, nécessite moins décritures |
|`ext3` |ext2 + journal, passage ext2 <-> ext3 |
|`ext4` |compatible ext3, meilleur allocation, vitesse de vérification rapide |
|`btrfs` |à terme nouveau FS de Linux, concurant à xfs, modif volumes à chaud, proche de LVM |
|`reiserfs` |1er FS journalisé, performant sur petits fichiers |
|`xfs` |journalisation très performante, Red Hat, snapshot, modif volume à chaud |
|`vfat` |toute version de FAT, pour petits volumes, simple, cross-platforme |
|`exfat` |défaut, pas de notion de droits, fichier max 4Go, remplacé par NTFS |

`exfat`: version amélioré de `vfat`
`NTFS`: pour partager Linux-Windows
`VFAT`: bcp de problèmes de brevets

# Partionnement
* découpage logique du disque, le disque physique, réel, est fractionné en plusieurs disques virtuels, logique, les partitions
* chaque partion est vue comme un disque indépendant avec son propre FS
* 2 méthodes de partionnements:
  * MBR: machines BIOS
  * GPT: machine UEFI (+BIOS)

### MBR
* position sur 32 bits
* 1 block = 512 ko
* 2 To max de partition
* le * utilisé mais bascule vers GPT car UEFI

MBR - 521 octets
gestionnaire d'amorcage (446 o) | tables des 4 partitions primaires (64 o) | signature (2 o)

### partition
* partitions primaires (4 dans MBR)
* partition primaire étendue (1 dans MBR)
* partitions logiques

disques IDE: 63 partitions max par disque
disque SCSI: 15 partitions max par disque
partition de 1 à n
n >= 5: partitions logiques
la partition primaire 4 (la dernière) est souvent primaire
1 à 3: primaire
4: étendu
5 à n: logique
`hda1`: disque IDE 1, 1ére partition primaire
`hdb5`: disque IDE 2, 5ére partition primaire

### EBR
* chaque partition étendue doit décrire les partitions logiques qu'elle contient
* doit disposer d'une table des paritions
* possède 2 enregistrements: 1er: position et taille d'une partition logique
2éme: vide si pas d'autre partition logique, sinon pointe sur autre EBR (liste chainée)
* 1 EBR = 1 partition décrite

### PBR ou VBR
* 1er secteur de chaque partition primaire ou logique
* peut contenir routine ou chargeur d'amorcage si vocation à petre booté
* quand pas de routine dans MBR, bios cherche dans PBR

### type de partition
* en hexa sur 1 octet
* respecter type partition/système de fichier

# Partionnement GPT
* UEFI remplace BIOS
* GPT remplace MBR
* adressage sur 64 bits
* bloc d'au moins 512 octets
* plus de notion de bloc mais de LBA
* LBA : Logical Block Addressing
* LBA 0: 512 premiers octets
* LBA 1: les 512 suivants

### GUID
* Global Unique Identifier
* unique 128 bits, ID de composant
* dans GPT, décrit, disque, id de type de partition, id d'une partition

### LBA 0
* conserver rôle de MBR
* protectiver MBR, permet de reconnaitre disque GPT

### LBA 1 (LBA -1)
* en-tête GPT
  * emplacement et taille du LBA -1
  * sommes de contrôles associées
  * 1ére et derniére adresse utilisable pour partition
  * le GUID du disque
  * adresse table de partition (LBA 2)
  * nb et taille des descripteurs de partitions
  * somme de contrôle de la table des partitions

### LBA 2 à 33
* descripteurs de partition (128 octets)
* 4 partitions par LBA
* 32 LBA -> 128 partitions max
* peut être modifié dans LBA 1
* sauvegarde en LBA -2 à -33
* descripteur de partition
  * type GUID de la partition
  * GUID de la part.
  * LBA de début de la part
  * LBA de fin de la partition
  * attributs de la partition
  * son nom

# Manipulation des partitions
```bash
# le plus ancien, le plus utilisé (menu), pour MBR
$ fdisk

# dérivé de fdisk
$ cfdisk

# compliqué mais précis
$ sfdisk

# opérations avancées, scriptable
$ parted

# equivalent fdisk pour GPT
$ gdisk
```

### manipulation partition MBR
```bash
$ fdisk -l
$ fdisk -l /dev/sda

# "p" pour print les partions
# "d" supprimer partition
# "n" créer partition
# "p" ou "e", primary ou extended
# choisir début de la partition
# +1024M ou + 64G
# "p" pour voir état
# "w" sauvegarder
# message d'avertissement normal
# forcer synchro: blockdev --rereadpt /dev/sdb pour relire la table de partition
# ou si parted est installé et blockdev ne fonctionne pas: partprobe /dev/sdb
# cat /proc/partitions | grep sdb -> pour voir partitions
# on peut maintenant utiliser la partition et y ajouter un FS
# modifier type partition
$ fdisk
# "t"
# "numéro partition"
# "L"
# "w"
# types les + utilisés: 83: type Linux
# 82: swap
# fd: type RAID
# 8e: type LVM
```

### manipulation parition GPT
```bash
$ gdisk /dev/sdb
# pas de notion de partition primaire ou étendue
# parition 1 à 128
# même fonctionnement que fdisk
# type avec 0 à la fin
# dangereux d'utiliser gdisk sur un disque MBR
```

# Manipuler les FS
### block
unité de base, atomique, fichier = nb de blocks
du, df, find utilise unité block
512 ou 1024 octets

### superblock
chaque FS à au moins 1 superblock
contient: type, taille, etat, info sur partitions, autre superblocks
existe plusieurs copies de ses super blocks

### tabke d'inodes
index node, noeud d'index, strcuture de données, representant un fichier
tous les inodes sont dans plusieurs tables d'inodes
1 fichier = 1 seul node
1 node = unique dans le FS
contenu: toutes les info d'un fichier, ne contient pas le nom du fichier, ni date de création (existe exception)
$ stat chap1.pdf
adresse dans inode: soit vers début données du fichier, soit vers block d'adresses, et ainsi de suite

### table de catalogues
|nom fichier       |inode     | 
|:-----------------|:---------|
|`mon_fichier.txt` |172781289 |
|`centos7.iso`     |211112999 |

possible de donner plusieurs nom à un même fichier

### hard link
reférence sur inode
limté dans le FS
ls -l -> 1: normal
si > 1 alors existe d'autre liens

# Créer système de fichier
```bash
# permet de trouver la commande associée
$ mkfs -f typefs options periph
# indiquer options après le typefs
# on peut directement appelé la vrai commande
# ext2 -> mkfs.ext2

$ mkfs -t ext2 /dev/sdb1
# on peut définir les options
# -b taille block, multiple de 512
# -c vérifier les mauvais blocks avant de créer le FS (execute badblock)
# -i ration octets/inodes
# -m pourcentage pour root
# -L label de la partition
# -j créer journal pour ext3

$ mkfs -t ext2 -j -b 2048 -i 16384 -m 0 -L "DATA" /dev/sdb1

# ext2 -> ext3
$ tune2fs -j /dev/sdb1

# ext3 -> ext2
$ tune2fs -O ^has_journal /dev/sdb1
# vérification fsck et supprime .journal

# ext3 -> ext4
$ tune2fs -O extends,uninit_bg,dir_index /dev/sdb1
$ fsck -pDF /dev/sdb1
$ mount /dev/sdb1 /mnt
# ajouter extends aux fichiers déjà existant
$ find /mnt -xdev -type f -exec chattr +e {} \;
# même chose avec -type d

# ext4 -> ext3
# si pas encore d\'extend: le monter en ext3
# sinon pas possible

# label
# afficher
$ e2label /dev/sdb1
# modifier
$ e2label /dev/sdb1 DATA # max 16 caractères sinon tronqué

# ReiserFS, xfs, btrfs, vfat
# voir les options associées

# les mtools: outils pour travailler sur FS FAT ou VFAT
```

# Accéder au système de fichier
```bash
# accéder aux partitions qui ont un FS
# info sur tous les montages actifs (aussi dans /etc/mtab)
$ mount

$ mount -t typefs -o options periph point_montage
$ mount -t ext4 /dev/sdb1 /mnt/DATA

# par label -> mieux !
$ mount -t ext4 -L DATA /mnt/DATA
# dans /dev/disk/by-label

# par UUID de partition
# udev avec vol_id dans /lib/udev/vol_id
$ ./vol_id -u /dev/sdb1

# maintenant
$ blkid /dev/sdb1
$ blkid -o value -sUUID

# si FS est ext2 ou 3
$ /dev/disk/by-uuid

$ mount -t ext4 -U 98766 /mnt/DATA

# remonter FS avprès modifs
$ mount -o ro,remount /mnt/DATA

# options de montage 
# p 311
```

### détacher point de montage
```bash
# ne doit plus être utilisé
$ umount /mnt/DATA

# connaitre utilisateurs
$ lsof /mnt/DATA

# forcer
$ fuser -km /mnt/DATA

# conf statique des montages, lu à chaque démarrage
/etc/fstab
periph | p_montage | typefs | options | dump | fsck

# montage automatique sauf si option noauto

# montage manuel
# recherche automatique dans fstab
$ mount /home
$ mount -L u01
mount LABEL=/boot
mount /dev/sda5

# tout monter
$ mount -a
```

# Controler le système de fichiers

### statistiques d'occupation
par système de fichier
```bash
# info sur fs montés
$ df

# info sur le fs
$ df sys_fichier ou point_montage

# info sur le fs qui le contient
$ df fichier.txt
# k, m
# -T: affiche type de fs
# -i: stats sur inodes 
```

par arborescence
```bash
# disque usage, espace occupé par arborescence
# dossier + contenu
$ du

# taille totale seulement
$ du -s /home

# par défaut visite autres FS
$ du -x /home
```

### vérifier, régler et réparer
```bash
# vérifier réparer FS, ne doit pas être monté ou ro
$ fsck

# comme mkfs, appelle d'autres commandes, fsck.ext2, fsck.ext3
# si pas de type, devine
$ fsck -t typefs periph

# forcer et verbeux
$ fsck -fV /dev/sda2

# si il faut réparation
# -p: automatique
# -y: répondre oui à toutes les questions

# existe vérification automatique, interval peut
# être modifié avec tune2fs

# BTRFS
$ btrfsck
$ btrfscheck

# vérifier blocs déféctueux
# appelé par mkfs ou fsck avec -c
$ badblocks
# -n: non déstructuf, lit et réécrit
# -w: destructuf avec modif
# éxecution très longue, pas de sens sur SSD

# donne info, utile avec grep, ext2,3,4
$ dump2fs

# modif paramètres en ext2,3
$ tune2fs

# pour ext2,3,4
$ debugfs
```

### XFS
par défaut dans RHEL, CentOS
```bash
# étendre parttion
$ xfs_growfs

# peut être agrandi, mais pas rétrécit
# nbr d'inodes non limités en xfs

# equivalent de fsck
$ xfs_repair

# affiche journal, log
$ xfs_logprint

# debugfs et tune2fs
$ xfs_db et xfs_admin
```

# le swap
théorie: 32 bits, process peut addresser à 4 Go d'espace mémoire (virtuelle) rien que pour lui, si dépasse, utilise le swap

### taille optimale
RAM | SWAP
<512 Mo | 2*RAM
1 Go à 4 Go | taille RAM
+4 Go | 4 Go, plus ou moins
256 Go | non 256 Go

### créer partitions swap
fdisk ou gdisk
synchroniser table de partitions:
```bash
$ partprobe

# préparer partitions à recevoir swap
$ mkswap /dev/sda5

# si swap > 2Go, alors plusieurs partitions de swap sur le plusieurs disques sur plusieurs controleurs materielle différent
```

### activer, désactiver swap
```bash
# activer
$ swapon /dev/sda5
# -p: priorité,de 0 à 32767
# varier si disque plus rapide qu'un autre

# activer toute parition de swap sans noauto
$ swapon -a

# désactiver
# s'assurer d'avoir de la place en RAM
$ swapoff /dev/sda5
# /proc/swaps: zones swap actives

# desactiver toutes les partitions de swap
$ swapoff -a

# en cas d'urgence, fichier de swap, p330
```

### etat de la mémoire
```bash
# info sur RAM
$ free

# FS virtuel
# /proc
# /proc/meminfo

# vider cache
$ sync ; echo 3 >/proc/sys/run/drop_caches
$ swapoff -a
$ swapon -a
$ free
```

### quotas disque
p336

# Droits d'accés
UID: user id
/etc/passwd: les users
GID: group ID
user avec group principal
/etc/group
$ id
fichier lié à UID et GID

```bash
# modifier droits
$ chmod -R
# u,g,o
# +,-,=
# r,w,x
# 4,2,1 # base 8

# droits de base fichier: 644
# droits de base dossier: 755

# ce que l'on retire de fichier: 666, dossier: 777
$ umask

# changer proprio
$ chown

# changer groupe
$ chgrp

# droits d'accés étendus
# executer commande avec droits sur proprio, ou groupe
# SUID et SGID
$ chmod u+s ou g+s
# 4000 ou 2000

# UID et GID reel: celui qui lance vraiment
# UID et GID effectif: celui deu process (si SUID ou SGID)
# SUID et SGID non transmis au fils

# sticky bit (bit collant)
# protection contre affacement
$ chmod u+t /tmp
# 1000

# repertoire
# si s au groupe, tout ce qui va être crée dedant partage le groupe du repertoire 
```

---
---

# Processus de démarrage

# BIOS et UEFI
* BIOS: Basic Input Output System
* interface logicielle entre matériel et logiciel à niveau très basique
* auto-test (POST) au démarrage pour détecter périphériques (dont celui pour démarrer)
* mémoire CMOS: alimentée par petite pile avec info materilles
* lit est éxecute 1er secteur d'amorçage (MBR ou PBR)

* UEFI: Unifed Extensible Firmware Interface
* seccesseur du BIOS
* interface entre firmware (micrologiciel) du matériel et l'OS
* amorçer OS via boot manager
* contrairement au BIOS, chercge tout le nécessaire pour lancer lui-même l'OS

# GRUB
* Grand Unified Bootloader
* chargeur par défaut
* options:
  * timeout: nb sec pour choisir
  * default n: preselection
  * title xxx: debut section, ligne menu
  * root(hdX,y), tous les accés fichiers en dessous sont depuis ce point
    (hd0,O): 1ère partition du 1er disque
    (fd0): 1er lecteur de disquette detecté BIOS
    (hd1,4): 5éme partition du second disque
  * kernel: nom de l'image du noyau suivi des param
  * initrd: initial ramdisk
  * rootnoverify: racine à ne pas monter par GRUB
  * chainloader + 1: démarre le 1er secteur de la racine spécifiée ci-dessus

### installation
```bash
# conf
$ cat /etc/grub.conf
$ cat /boot/grub/menu.lst

# peut s'installe sur MBR ou PBR
$ /sbin/grub-install /dev/sda
```

### démarrage
choisir image au boot
`e` pour éditer param passés au noyau
`e`: editer ligner
`d`: supprimer ligne
`o`: ajouter ligne
`b`: booter

# GRUB 2
* réécriture complète de GRUB
```bash
# de GRUB à GRUB2
$ upgrade-from-grub-legacy

# modules en .mod

# config menu
$ cat /boot/grub[2]/menu.cfg
# mais pas touché car généré automatique par
# utiliser à chauqe ajout de noyaux ou script
$ update-grub
$ grub2-mkconfig -o /boot/grub/menu.cfg

# fichiers lus
$ /boot/grub/device.map # correspondance nom disque Linux et GRUB
$ /etc/default/grub # param par défaut de GRUB
$ /etc/grub.d/* # par ordre de listage qui génére les menus

# ordre
$ 10_linux # cherche noyaus
$ 30_os_prober # cherche autres OS sur le disque

# générer device.map
$ grub-mkdevicemap
# sinon
$ grub2-install --recheck

# variables de GRUB2 + options (p355)
$ /etc/default/grub

# trouver OS sur disque
$ $ os-prober
```

### ordre
* traces noyau dans /var/log/dmesg
* matériel detecté et initialisé
* initrd est chargé + modules
* noyau monte le FS racine en read only
* crée première console
* 1er process est lancé (init)

* autre chargeur: LILO (Linux Loader) mais disparait

# Init Sytem V
### rôle
* programme init
* 1er lancé et dernier stoppé
* lance toutes les autres tâches
* pére de tous les process
* PID = 1
* lancé par noyau (PID = 0, virtuel)
* conf: /etc/inittab

### runlevels
* 0: halt, stoppe l'OS et machine
* 1: mono-utilisateur, maintenance en mode console
* 2: multi-user, sans réseau console
* 3: précedent + réseau
* 4: précedent + selon admin
* 5: avec réseau + X window
* 6: reboot
S,s: single, user mode
dans /etc/inittab: id:5:initdefault

dans /etc/inittab
id:[niv]:action:commande
id: identifiant de la ligne
niv: liste des runlevels sans séparateurs
action: type d'action à effectuer (p361)
commande: commande à éxecuter

### changement de runlevel
```bash
$ /sbin/init

$/sbin/telinit 5
# -q: relit /etc/inittab
# -U: init se lance sans relir inittab et sans changer niveau
# -t

# donne niveai d'éxecution
$ runlevel
# precedent actuel
```

### paramétrage système de base
quelques soit le runlevel, init lance toujours la commande associée aux actions:
sysinit, bootwait ou boot
RH: si::sysinit:/etc/rc.d/rc.sysinit
OpenSUSE: si::bootwait:/etc/init.d/boot
Debian: si::sysinit:/etc/init.d/rcS

### niveaux d'éxecution
/etc/init.d/rc prend runlevel en param et s'occupe de tout

### gestion des niveaux et services
* runlevel défnit les services à démarrer
* script rc qui les charge
* services controlés par: start, stop, reload, status avec les scripts dans /etc/init.d/
* pour chaque runlevel, existe répertoire rcN.d qui contient liens symb vers les services presents dans /etc/init.d

RH: /etc/rc.d/rcN.d et liens sur /etc/rcN.d
OpenSUSE: /etc/init.d/rcN.d sachant que /etc/rc.d pointe sur /etc/init.d
Debian: /etc/rcN.d

Les liens sont présents dans les rcN.d ont des noms particuliers
[SK]NNservice
S: start
K: kill
NN: ordre démarrapge/arrêt (00: premier, 99: dernier)
service: nom du service

Quand on execute rc, il liste tout les services à stopper et les stoppes, ensuite tout ceux à démarrer et les start.

### contrôle manuel des services
utiliser les scripts de /etc/init.d/*
```bash
$ /etc/init.d/ssdd start
# stop
# probe: faut-il reload apres modif de la conf ?
# reload, forcereload
# restart
# try-restart: restart SSI arrêt à bien fonctionner

# via commande service
$ service sshd stop
# conseiller d'utiliser ce system, que d'appeler directement les scripts
```

# Modification des niveaux d'éxecution
RH, SUSE
```bash
# ajouter, supprimer, activer, désactiver des services par niveau d'éxecution
$ chkconfig
# --list [service]: affiche [toute] la conf
# --add service
# --del service
# --level xxx service on/off: activer pour level
$ chkconfig --level 35 smb on
```

Debian
```bash
# crée des liens dans les rcN.d
$ update-rc.d

# ajoute service avec param par défaut: start en 2 et 5
# stop en 0,1,6
# en position 20
$ update-rc.d ssh defaults

$ update-rc.d ssh start 10 3 4 5 . stop 05 0 1 6

# supprimer
$ update-rec.d -f ssh remove
```

### console virtuelle
défini dans /etc/inittab
dispo dans /dev/ttyN
N: num de consol
depuis console: Alt + Fn
depuis X: Ctrl + Alt + Fn
Alt + -> ou Alt + <-
6 dispo par défaut
x window est lancé par défaut sur la premiére dispo (la 7)

### login
* terminaux lancés par init
* prompt attend saisie du nom
* affiche /etc/issue
* validation
* execution de la commande login
* qui attend mdp
* si mdp ok, affiche /etc/motd
* execute shell de /etc/passwd

pas de fork mais substitution (exec), init sait facilement qu'une connexion est terminée

### arrêt
```bash
$ init 0
$ init 6
# mais pas supe

# appel init
$ shutdown
# -k: envoi juste message à tout le monde
# -r: reboot
# -h: halt
# -f: enpêche fsck au boot
# -F: force fsck
# -c: annule le shutdown sans délai

$ shutdown -r +10 "Reboot dans 10 min"
$ shutdown -c "Maintenance annulée"

$ halt # = shutdown -h
$ reboot # = shutdown -r
```

### systemd
* system deamon
* système d’initialisation
* lance processus au démarrage
* les gérer tout au long de leur exécution
* conçu pour tourner avec le noyau Linux

### Processus systemd
* premier processus lancé
* dernier à s’arrêter
* PID 1
* PPID 0 (noyau)

### Histoire
* successeur d'init System V, (`init`)
* successeur  d'`upstart` » (développé par Canonical (Ubuntu))
* systemd est réputé pour être plus performant que ces derniers

systemd manipule des `units` qui sont de différents types:
* cibles ou `targets`
* `services`

Les `units` sont dans `/lib/systemd/system/*` sous forme de fichiers.

Dans `systemd`, il n’y a plus réellement de notions de « `runlevels` », ou niveaux d’exécutions, initialement présent dans init System V. Ces niveaux sont remplacés par des `tagets`. On peut encore trouver des traces de `runlevels`, mais sont souvent utilisées pour assurer une retro compatibilité avec « `init` ». Systemd est complètement compatible avec `init`, mais l’inverse n’est pas vrai.

Voici les correspondances entre les runlevels et les targets de `systemd` :

| init (runlevel)| systemd            |
|:---------------|:-------------------|
| `0`            | `poweroff.target`  |
| `1`            | `rescue.target`    |
| `2/3/4`        | `multi-user.target`|
| `5`            | `graphical.target` |
| `6`            | `reboot.target`    |

Pour connaitre le runlevel d’une machine: `$ systemctl get-default`

On remarquera que la cible « `default.target` » qui se trouve dans `/lib/systemd/system/*` est un lien symbolique qui pointe vers le « `.target` » du runlevel actuel.

Changer runlevel : `$ systemctl set-default multi-user.target`. Ce qui aura pour effet de simplement modifier le lien symbolique de default.target. 

Appliquer la nouvelle cible à l’exécution courante: `$ systemctl isolate multi-user.target`

Requires: dépendances obligatoires
After: exemple d'ordre

```bash
# lister les cibles ou services actifs
$ systemctl list-units -–type target
$ systemctl list-units –-type service

# afficher toutes les cibles ou services
$ systemctl list-units -–type target –all
$ systemctl list-units –-type service –all

# afficher une liste complète
$ systemctl list-unit-fils –-type target/service
$ systemctl list-unit-fils –-type service

# gérer un service
$ systemctl status sshd
$ systemctl start sshd
$ systemctl stop sshd
$ systemctl reload sshd
$ systemctl enable sshd
$ systemctl disable sshd
$ systemctl is-enabled sshd

# afficher les dépendances d’une unité
$ systemctl list-dependencies –-before ssh
$ systemctl list-dependencies –-after ssh

# gérer la machine
$ systemctl halt
$ systemctl poweroff
$ systemctl reboot
$ systemctl shutdown

# Masquage
# un service désactivé (disabled) et stoppé, peut tout de même tourner car il peut être issu d’une dépendance. On peut interdire ce comportement avec :
$ systemctl mask sshd
$ systemctl unmask sshd

Remarque : l'activation d'un service ajoute un lien vers l’unité active vers le `.taget.want/` actuel.

### upstart
```bash
remplace init par ubuntu, système d\'évenements
conf /etc/init, syntax spécifique + code shell
$ start, stop, restart, status ssh

# controler services
$ initctl list
$ initctl emit runlevel
```

# Consulter les traces système

### dmesg
$ dmesg -T: affiche temps
$ dmesg -k: -lwarn,err

### /var/log/messages et /var/log/syslog
kernel + services geré par syslog

### journalctl
$ journalctl -k -p warning,emerge
$ journal -k = dmesg

# Serice et modules noyau
### présentation
noyau linux (linus T) + outils GNU
noyau  monolithique: fonctionnalités et composants sont regroupés dans programme unique
depuis v 2.0 devenu modulaire
kernel dans /boot
vmlinuz-X.Y.Z.p-Vtxt
uname -r

### uname
unix name
```bash
$ uname
# -m: machine type materiel
# -n: nodename: hostname
# -r: release, num noyau
# -s: system name, nom OS
# -p, processor, type processor
# -i: plate forme materiel
# -v: versio
# -a: all
```

### gestions des modules
dans /lib/modules/$(uname -r)
fichiers en .ko (kernel object)
```bash
# tous les mod avec leur dépendances
$ lsmod
# nom taille nb_utilisateurs depandances
# affiche cotenu de /proc/modules

# màj arbre de dépendances
# en modifiant /lib/modules/$(uname -r)/modules.dep
$ depmod

# aprés installation de mudoles
$ depmod -a

# info
$ modinfo [parpot]

# alias pour connaitre les périph qu'il doit gérer
# les param sont passés au modulle via les commandes insmode ou modprobe à l'aide du fichier /etc/modprobe.conf ou dans le .d/*

# charge module mais ne s'occupe pas des dépendances
$ insmod lp.ko
# -k: autoclean des modules non utilisés

# avec param
$ insmod wcvideo.ko trace=5

# decharger module, ne gére pas les dépendances
$ rmmode perpot

# charge module + toutes ses dépendances
# avec param dans /etc/modprobe.conf
# ou /etc/modprobe.d/*
$ modprob
# -r: decharge + dépendances si pas utilisées

# confi toujour dans le .d en /etc/modprobe.d/*.conf
# système d'aliases
```

# Chargement des modules au boot
initial ramdisk
initrd: permet de stocker module necessaires au boot car les modules sont dans le DD alors qu'on a pas le module pour monter
* un initrd par noyau
* son contenu: zcat /boot/initrd.... | cpio -id --no-absolute-filenames
* execute le sciprt init à la racine pour charger modules nécessaires
* puis passe la main à /sbin/init

### construire initrd
RH, SUSE: mkinitrd
Debian: mkinitramfs
on peut y ajouter des modules

maintenant
initramfs
conf: /etc/initramfs-tools
$ mkinitramfs -o /tmp/initrd-$(uname -r)

# FS virtuel
/proc
/sys
FS virtuel avec info sur le système
avant proc tout seul
pas de place mémoire

# sysctl
systemd-sysctl appel sysctl
pour faire modif permanente dans /etc/sysctl.co,f ou .d
sysctl -a
net.ipv4.ip_forward=1

# Compiler un noyau
noyau vanilla: brut
sources, configurer, compiler, installer
installer xz-utils
tar tvJf linux-...
source dans /usr/src/linux ou /usr/linux-sources-... ou /usr/src/kernels

### récupérer les sources
D: linux-sources-x.y...
RH: kernel-sources

### config
avec le .config
y: intégrer au noyau
m: compiler en module
n: fonctionnalité abscente

config des anciens noyaux dans /boot
peut le copier et le réutiliser pour le nouveau
ensuite make oldconfig + question pour màj

make menuconfig + interface avec choix et génére le .config
make xconfig: graphique

p416: optimisation en désactuvant modules

### compilation
make -j 3
long

### installation
make modules_install # install modules dans /lib/modules/noyau
make install # recopie noyau dans /boot

si pas de initrd
cd /boot
mkinitramfs -o initrd.img-4.9...

si nouveau noyau non pris en compte:
grub-mkconfig -a /boot/grub/grub.cfg

make clean # supprimer fichiers objets

sous yum: make rpm pour créer packahe source, header, noyau

### les fichiers periph
dans /dev
créer fichier spécial
mknod /dev/periph

# Connaitre son matériel
bus PCI: lspci
-v: details
-s: spécifier adaptateur
$ lspci -v -s 02:00.0

bus USB: lsusb
-d: info
-v: info

kwinfo --short, --cpu --memory
BIOS dmidecode -t processor

# udev, fs dynamique, remplace devfs
gere tout /dev
est composant de systemd
lancé comme service classique
noyau génère des events et udev les lit et les interpréte
régles dans /etc/udev/rules.d ou /lib/udev/rules.d

périph controlé par udev:
udevinfo --query=all -n /dev/sda
ou udevadm info --query=all -n /dev/sdb

---
---

# Les tâches administratives
# Administration des utilisateurs
identification: savoir qui est qui, pour connaitre les droits (login)
authentification: apporter preuve de qui on est (mdp)

utilisateur = login + UID + GID
les UID et GID sont dans tables de inodes
GID: groupe principal
UID < 100: comptes spéciaux
UID de root = 0
UID > 100, 500, 1000: user normal
/etc/login.defs

groupe primaire: utiliser pour créer les fichiers
$ id mourad

/etc/passwd: liste de user
login
password -> x: /etc/shadow et !: compte vérouillé
UID:GID:comment:home directory:shell

/etc/group
nom:password:GID
liste des users dont c'est un groupe secondaire
mdp sur un groupe pour éviter de passer en groupe primaire avec newgrp

/etc/shadow
login
mdp $xx$: type de chiffrement
nb jours depuis 1 janvier 1960 du dernier changement de mdp
nb jours avant lesquels le mdp ne peut pas être changé (0: peut être changé n'importe quand)
nb jours après lesquels le mdp doit être changé
nb jours avant l'expiration du mdp durant lesquels l'utilisateur doit être prévenu
nb jours aprés experiration le compte est désactivé
nb jours depuis 70 desactivation
reservé

$1$: MD5
$2a$: Blowfish
$5: sha-256
$6: sha-512
autres: DES

man crypt

/etc/gshadow
c'est /etc/shadow pour les groupes
nom du groupe:mdp:admin du groupe:membres

# Gestion des utilisateurs
### ajout
ajouter lignes dans
/etc/passwd
/etc/shadow
/etc/group
/etc/gshadow
copie de /etc/skel
changer droits de la copie
changer mdp

possible à la main, mettre à jour: vipw

$ useradd mourad
-m: créer home directory
-u: préciser UID
-g: préciser group principal
-G: groupe additionnels, séparés par virgule
-d: chemin home directory
-c: commentaire
-k: chemin vers le skel
-s: shell, avec chsh
-p: mdp chiffré, avec passwd

créer mdp
$ passwd mourad
### sécurité des mdp
passwd: gérer /etc/shadow
module PAM peut imposer contraintes sur le mdp
root peut changer sans contraintes

### gérer info de validalité du mdp
passwd et chage
chage -l mourad: info

modif:
usermod, même option que useradd
-L: lock du compte
-U: unlock
-e <n>: mdp expire aprés n jours
-l: modifier login
-m: move home directory

$ chage mourad : intéractive pour changer les dates
$ chage -l mourad: info date pour user

### suppression
userdel
-r: supprime home directory

# Gestion de groupe
### ajout
groupadd
-g: GID

### modif
groupmod
-n: renommer
-g: GID, le groupe d'appartenance des fichiers n'est pas modifié

### suppression
groupdel
vérifier d'abord que ce n'est pas le groupe principale d'un user et ensuite supprimer
vérifier traces du groupe dans tout le système

### mdp
gpasswd test
gpasswd -a seb test
ajouter seb dans groupe test

gpasswd -M seb,steph test # membres groupe
gpasswd -A admin test

# commandes additionnelles
### conversion des fichiers
pour migration sur system qui ne supporte que passwd et non shadow
shadow + passwd -> unique passwd
avec pwunconv (plus de durée de validité des mdp)
pwconv fait l'inverse
groupe: grpconv et grpunconv

### vérifier la cohérence
pwck: vérification de passwd et shadow
grpck

### vérifier les connexions
lastlog
se base sur /var/log/lastlog
-u: user
-tn : des n derniers jours

last
se base sur /var/log/wtmp
ip, date co, date deco, durée co, status

# Action de l'utilisation
chsh
-l: affiche /etc/shells
-s: /bin/sh

chfn: change commentaire

newgrp mon_groupe: change groupe principal temporairement qui doit être secondaire ou avoir mdp
newgrp seul: revenir en arrière

changer identité
su (substitute user)
su - seb: charger en + l'environnement
su -c "make install"
sg pour les groupes

intéroger système
getent: intérogger les systèmes en passant par ses biblio NSS(name server, switch sans passer pas fichiers locaux mais par LDAP, NIS, AD)
getent passwd
getent shadow
getent group
getent gshadow

configuration avancée
/etc/login.defs: utilisé par pas mal de commande pour des valeurs par d"faut ou régles

notification à l'utilisateur
/etc/issue: message d'accueil
/etc/issue.net: message d'accueil depuis ssh
/etc/motd: message of the day
wal, write et mesg
wall: pour tous les users
write: pr 1 utilisateur
mesg y/n; recevoir ou non les messages

# l'environnement utilisateur
/etc/skel (skeleton): copié dans les homes
/etc/profile: définit PATH, LOGNAME, USER, HOSTNAME HISTSIZE, MAIL, INPUTRC
/etc/profile.d/*
~/.bash_profile
~/.bashrc
/etc/bashrc

# apercu de PAM
pluggable authentification modules
ensemble de modules, biblio, pour mettre en place des systèmes d'authentification avancés
unix classique, LDAP, AD

# l'impression
### principe
3 standards sous Unix, sous sytem V, sous BSD
imprimantes dans /etc/printcap avec file d'attente (queue)
pour imprimer documents formatés ou images, il faut (pilotes) filtres d'impression entre le doc et la communication
prendre imprimante compatible avec Postscript

system V: lp
BSD: lpr

CUPS: commun unix printing system
système d'impression Unix orienté réseau, IPP avec HTTP
cupsd localhost:631
/etc/cups/cupsd.conf

# Automatisation
### avec cron
avec crontab
crontab -e: editer tab perso
sont dans /var/spool/cron/*
service cron doit tourner
min heure jour_du_mois mois jour_semaine cmd
15 ou 15,16,20 ou 15-30 ou *
0: lundi
*/5: toutes les 5 min
2-57/5: 2,7,12,...
crontab -l: crontabs actives
crontab -r: supprimer
crontab -u user: editer

crontab système + utilisateur
/etc/crontab
on peut préciser var. d'environnement
run-parts: prend en param un repertoire et exécute tous les programmes qui sont à l'intérieur
logrotate: effectue sauvegarde et renomme fichiers de logs et journaux
tmpwatch: chargé de nettoyer le sys de fichiers inutilisé (/tmp)
/etc/crond.d/ au système

contrôle d'accés
/etc/cron.allow
/etc/cron.deny

### avec at
atd (at deamon)
modif vilatiles
at 21:20: donner commandes et EOL
at -f /home/seb/test.sh  21:25
heure: hhmm ou hh:mm
MMJJAA ou xx/xx/xx
...

batch: execute lorsque la charge de la machine est basse
atq (at queue): tâche programmés
/var/spool/atjobs: 1 executable par tâche
atrm 10: supprimer un job

contrôle d'accés
/etc/at.allow
/etc/at.deny

### avec anacron
/etc/anacrontab
anacron peut remplacer cron sur machine souvent éteinte
cmd exécuté dés que la période est atteinte ou dépassée
execution périodique
periode delai identifiant cmd
7 10 cron.weekly nice runparts --report /etc/cron.weekly
tous les 7 jours, 10 min après le lancement

# Les traces (logs) du sytème
### principe
services spécialisés dans la réception de message pour les logs
klogd: kernel log deamon, emis par kernel
syslogd: sys log deamon, emis par services (+ un peu kernel)
journald: composant de systemd, tout service
(syslog-ng ou rsyslog)

klogd
gére logs emis par noyau
- 2 src d'accés: /proc (/proc/kmsg): s'il est présent,
- appels système via API (sys_syslog) si /proc est absent, ou explicite

message noyau avec niveaux
0: EMERG: sys inutilisable
1: ALERT: action doit être prise immédiatement
2: CRIT: prob. critique
3: ERR: erreur
4: WARNING: avertissement
5: NOTICE: normal mais nécessite attention particulière
6: INFO: info standard
7: DEBUG: trace debug noyau

klogd: envoi 0-6 à syslogd
7: ne sont pas tracés par défaut

### configuration syslog
/etc/syslog.conf
permet de définir l'origine, l'importance et la dest de chaque message, sous forme de 2 champs
l'origine:
auth,authpriv: secu et authentification
cron: service cron
deamon: demons sys
kern: noyau
lpr: service d'impression
mail: messagerie
news: le réseau
syslog: syslog lui-même
user: message des process utilisateurs
uucp: Unix to Unix CoPy
local 0->7: issus de klogd

l'importance
emerg
alert
crit
err
warning
notice
info
debug
none: ignorer les mess

la destination
fichier

envoyer message à syslogd avec "logger"

### cas de rsyslog
/etc/rsyslog.conf

### systemd et journal
journal démarré par systemd
avec des avantages
stocké en binaire dans /run/log/journal
le FS /run est volatile, vidé à chaque redémarrage, on des places vers /var
mkdir /var/log/journal
systemd-tmpfils --create --prefix /var/log/journal
systemctl restart systemd-journald
commande journalctl pourexploitation
/etc/systemd/journal.conf
options: p486

### les fichiers de traces
/var/log

### journalctl
accéder aux traces stockés par journalctl
journalctl -f: tail -f
journalctl _SYSTEMD_UNIT=ssh.service
ajouter option à la fin
since: -S "2017-01-29 09:00:00"
until: -U "2017-01-29 09:00:00"

-o: modifier format de sortie

# Archivage et backup
### les outils de sauvegarde
tar: fichier et arborescences (ou cpio)
dd (dump): sauv physqiue de disque ou de FS
sauv incrémentale (première grosse et des petites)
autre solution Networker
plan de sauvegarde
les trucs à protéger ?

### autres commandes
mt: contrôle d'une bande magnétique
touch: màj date de last modif pour forcer sauv. incrémental
find: selectionner fichiers à sauv
compress et uncompress des fichiers
gzip, gunzip, zcat
xz, unxy, xzcat

### tar
simple et efficace
pour créer archives
tar cvf desktop.tar Desktop/
-c: créer archive
-v: verbeu
-f: nom archive

lister:
tab tcf desktop.tar

resauration
tar xvf desktop.tar
-x: extraction

autres param
compression:
-z: gzip
-Z: compress
-j: bzip2
-J: xy

tar cvzf desktop.tar.gz Desktop/

### cpio
sauvergarde sur la sortie standard
les fichiers de sont entré standard (redirection)
ne compress pas les archives
cpio -oL
-o: output, création de la sauv en sortie
-L: sauvegarder les fichiers et pas les liens s.
-v: verbose
-c: sauvegarder des attributs des fichiers ss-forme ASCII
find Desktop -rpint | cpio -ocv | gzip > archive.cpio.gz

lister
cpio -it archive
-i: lecture de l'archive en entrée
-t: lister contenu
cat archive.cpio.gz | gzip -cd | cpio -it
restaurer
prec + | cpio -iuvd

### dd
device to device
copie physique, bloc par bloc d'un fichier periph vers un autre
créer fichier vide de 1Mo
dd if=/dev/zero of=vide les=446 count=1024
count: nb blocs à copier

### l'horloge
connaitre l'heure
date
strftime en C
date avec pleins d'options

### NTP
network time protocol
synchro de horloges

# les param régionaux
dpkg-reconfigure locales
LANG
D,U: /etc/default/locale
RH: /etc/locale.conf
SuSE: /etc/sysconfig/language

LANG=fr_FR.UTF-8
langue_Pays[.norme][@variante]

export LANG=en_US.UTF-8

supporté par système:
locale -a
/usr/share/locale
toutes les variables LC implique format mais LANG les surclasses

### fuseaux horaire, timezone
D,U: dpkg-reconfigure tzdata ou timedatectl
RH7: timedatectl
RH6: system-config-date, redhat-config-date
autres: timedatctl

/etc/timezone continent/ville
/etc/localtime binaire,info sur timezone
avec decalage + changement d'heures

les fichiers de conf des timezones
/usr/share/zoneinfo
/usr/share/zoneinfo/Europe/Paris
lins s. de /et/localtime lors de config
echo $T2

codage des caractères
unicode pour tout simplifier
unicode UTF-8
iconv -f WINDOWS-1252 -t UTF8 nom_fichier

# ACL
Be able to add a right system to classic POSIX system (owner, group, other).

```bash
$ setfacl -m u:mourad:rx ./mon_fichier
$ setfacl -m g:grp_admin:rwx ./mon_fichier

$ setfacl -bm u:mourad:rx ./mon_fichier # default
$ setfacl -Rbm u:mourad:rx ./mon_fichier # reccursive

$ getfacl ./mon_fichier

setfact -b # delete all permission
setfact -k # delete just default permission
setfact -x u:mourad:rx # delete particular line
```


# Colors
```bash
NC='\033[0m' # Aucune couleur
Red='\033[0;31m'
Green='\033[0;32m'
Yellow='\033[0;33m'
LINE="____________________________________________________________"

if [ ! -f /home/test.txt ]; then
 #touch /home/test.txt
 if [ $? -eq 0 ]; then
     echo -e "${LINE} [${Green} OK ${NC}]\rCreating /home/test.txt "
 else
     echo -e "${LINE} [${Red} FAIL ${NC}]\rCreating /home/test.txt "
 fi
else
   echo -e "${LINE} [${Yellow} ALREADY EXISTS ${NC}]\rCreating /home/test.txt "
fi
```

# Userdel
<!--more-->
On veut supprimer l'utilisateur jean
```bash
# lock account
passwd -l jean

# backup
tar -zcvf /var/backup/account/deleted/j/jean.$uid.$now.tar.gz /home/jean/

# running process
ps -fp $(pgrep -u jean)
killall -KILL -u jean

# delete jobs
find /var/spool/at/ -name "[^.]*" -type f -user jean -delete

# delete cron jobs
crontab -r -u jean

# remove printf jobs
lprm jean

# find all files
find / -user jean -exec chown newUserName:newGroupName {} \;

# finally delete user
userdel -r jean
```

# cron
```bash
# éditer la crontab
$ crontab -e

# afficher le contenu
$ crontab -l
```
```bash
# Example of job definition:
# .---------------- minute (0 - 59)
# |  .------------- hour (0 - 23)
# |  |  .---------- day of month (1 - 31)
# |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...
# |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat
# |  |  |  |  |
# *  *  *  *  *  user command to be executed

```